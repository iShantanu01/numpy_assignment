# -*- coding: utf-8 -*-
"""numpy_assignment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1k-UlX4YQz7ggHMVOsWwjTRFdOO-w7KzD
"""

import numpy as np
import pandas as pd

# Q.1 Create a NumPy array 'arr' of integers from 0 to 5 and print its data type.
# create the array
l=[0,1,2,3,4,5]
arr=np.array(l)

# show the array
arr

#show the type
type(arr)

# Q.2 Given a NumPy array 'arr', check if its data type is float64.

# given array
arr = np.array([1.5, 2.6, 3.7])

# show the array
arr

# check  the datatype
arr.dtype

# Q.3 Create a NumPy array 'arr' with a data type of complex128 containing three complex numbers.

# list  of complex number
l=[ 3+5j , 7+8j , 9+10j]

# create the array of complex number
arr=np.array(l)

# show the array
arr

# show the data type of the array
arr.dtype

# Q.4  Convert an existing NumPy array 'arr' of integers to float32 data type.

# list
l=[2,6,7,9,10]

# create the array
arr=np.array(l)

# show the array
arr

# now convert array element into float:
arr=arr.astype('float32')

# now show the array
arr

# now show the data type of the array
arr.dtype

# Q.5  Given a NumPy array 'arr' with float64 data type, convert it to float32 to reduce decimal precision.

# list
l=[2.0,6.4,7.1,9.5,10]

# create the array
arr=np.array(l)

# show the array
arr.dtype           # o/p- float64

# now convert array element into float:
arr=arr.astype('float32')

# now show the array
arr

# now show the data type of the array
arr.dtype

# Q.6 Write a function array_attributes that takes a NumPy array as input and returns its shape, size, and data type.

# create the function
def array_attributes(arr):
    return f"array shape is {arr.shape} , array size is {arr.size}  , array data type is {arr.dtype}"

# create an array
r = np.random.rand(3,4,2)

# show the array
r

# test the function
array_attributes(r)

# Q.7 Create a function array_dimension that takes a NumPy array as input and returns its dimensionality.

# define the function
def array_dimension(arr):
    return f"array dimension is {arr.ndim}"

# given array for the test
r = np.random.rand(3,4,2)

# show the array
r

# test the function
array_dimension(r)

# Q.8  Design a function item_size_info that takes a NumPy array as input and returns the item size and the total size in bytes.

# define the function
def item_size_info(arr):
    return f"item size is {arr.size} and the total size in bytes is {arr.nbytes} "


# given array for the test
r = np.random.rand(3,4,2)


# show the array
r

# test the function
item_size_info(r)

# Q.9  Create a function array_strides that takes a NumPy array as input and returns the strides of the array.

# Define the function
def array_strides(arr):
    return f"array strides is {arr.strides}"

# given array for the test
r = np.random.rand(3,4,2)


# show the array
r

# test the function
array_strides(r)

# Q.10  Design a function shape_stride_relationship that takes a NumPy array as input and returns the shape and strides of the array.

# Define the function
def shape_stride_relationship(arr):
    return f"array shape is {arr.shape} array strides is {arr.strides} "

# given array for the test
r = np.random.rand(3,4,2)


# show the array
r

# test the function
shape_stride_relationship(r)

# Q.11 Create a function `create_zeros_array` that takes an integer `n` as input and returns a NumPy array of zeros with `n` elements.

# define the function
def create_zeros_array(n):
  return np.zeros(n)

# test the function
create_zeros_array(10)

# Q.12 Write a function `create_ones_matrix` that takes integers `rows` and `cols` as inputs and generates a 2D
# NumPy array filled with ones of size `rows x cols`.

# define the function:
def create_ones_matrix(rows,cols):
  return np.ones((rows,cols))

# test  the function
create_ones_matrix(3,4)

# Q.13 Write a function `generate_range_array` that takes three integers start, stop, and step as arguments and creates
#      a NumPy array with a range starting from `start`, ending at stop (exclusive), and with the specified `step`.


# create a function
def generate_range_array(start , stop , step):
   return np.arange(start , stop , step)

# call the function
generate_range_array(2,20 ,2)

# 14. Design a function `generate_linear_space` that takes two floats `start`, `stop`, and an integer `num` as
#   arguments and generates a NumPy array with num equally spaced values between `start` and `stop` (inclusive).

# create a function:
def generate_linear_space(start , stop , num):
   return np.linspace(start , stop ,num)

# call the function
generate_linear_space(2.3 ,20.5 , 10)

#  15. Create a function `create_identity_matrix` that takes an integer `n` as input and generates a square
#      identity matrix of size `n x n` using `numpy.eye`.

# create a function:
def create_identity_matrix(n):
    return np.eye(n,n)



# call the function
create_identity_matrix(5)

# create a function:
# call the function

# 16. Write a function that takes a Python list and converts it into a NumPy array.

# list
l = [1,4,5,7,8,9,0,10]

# convert a list into a numpy array.
np.array(l)

# note- as type of function is not mention I do prefer built-in function to do this.

# 17. Create a NumPy array and demonstrate the use of `numpy.view` to create a new array object with the
#     same data.

# create an array:
arr = np.array([1,5,7,8,9,20] , dtype=np.int32)

# use-1
view_arr = arr.view()
# modify the array
view_arr[4] = 100

# output after modification:
print('this is arr' , arr)
print('this is view_arr' , view_arr)


# use-2  (different datatype)
view_arr1 = arr.view(np.int16)

# output after modification
print('this is arr' , arr)
print('this is view_arr' , view_arr1)

# 18. Write a function that takes two NumPy arrays and concatenates them along a specified axis.


# arrays:
arr1 = np.array([1,5,6,7])
arr2 = np.array([2,7,9,17])

# concatiantion:  (axis =0)
np.concatenate((arr1 , arr2 ) ,  axis =0)

# 19. Create two NumPy arrays with different shapes and concatenate them horizontally using `numpy.concatenate`.

# arrays:
arr1 = np.random.randint(2,5 , (3,2))
arr2 = np.random.randint(4,9 , (3,4))

print('this is arr1' , arr1)
print('this is arr2' , arr2)

# # concatiantion:  (axis =0)
np.concatenate((arr1 , arr2 ) ,  axis =1)

# 20. Write a function that vertically stacks multiple NumPy arrays given as a list.

arr1 = np.array([[1, 2, 3],
                   [4, 5, 6]])

arr2 = np.array([[7, 8, 9],
                   [10, 11, 12]])

arr3 = np.array([[13, 14, 15]])


# define a function:
def array_stocks(arrays):
    return np.vstack(arrays)

array_list= [arr1,arr2,arr3]

# call the function:
array_stocks(array_list)

# 21. Write a Python function using NumPy to create an array of integers within a specified range (inclusive)
#     with a given step size.


# create a function:
def int_arr(start , stop , step):
    return np.arange(start , stop+1 , step, dtype =int)

# call the function
int_arr(2,40 ,1)

# 22. Write a Python function using NumPy to generate an array of 10 equally spaced values between 0 and 1(inclusive).

# i use the direct funtion as no function type is mentuoned
np.linspace(0,1,10)

# 23. Write a Python function using NumPy to create an array of 5 logarithmically spaced values between 1 and
#     1000 (inclusive).

# define the function
def log_array(start , stop , num):
   return np.logspace(np.log10(start), np.log10(stop), num)

# call the function:
log_array(1,1000 ,5)

# 24. Create a Pandas DataFrame using a NumPy array that contains 5 rows and 3 columns, where the values
#     are random integers between 1 and 100.

# create the dataframe
df = pd.DataFrame(np.random.randint(1,100 , (5,3)))

# this is the output
df

# 25. Write a function that takes a Pandas DataFrame and replaces all negative values in a specific column
#     with zeros. Use NumPy operations within the Pandas DataFrame.


# create datafrme:
df = pd.DataFrame( {'Name':['a' , 'b' ,'c' ,'d' ,'e'] ,
                    'no':[-1 , -3 , 0 , 4 , -5]})

# define a unction
def dataframe_manipulation(dframe , col_name):
      dframe[col_name] = np.where(dframe[col_name] < 0, 0, dframe[col_name])
      return dframe

# call the function:
dataframe_manipulation(df , 'no')


# df[df['no']<0]['no']

# 26. Access the 3rd element from the given NumPy array.

# given array:
arr = np.array([10, 20, 30, 40, 50])

# access the 3rd element:
arr[2]

# 27. Retrieve the element at index (1, 2) from the 2D NumPy array.

# given array
arr_2d = np.array([[1,2,3],
                  [4,5,6],
                  [7,8,9]])
# index(1,2) means 2nd row 3rd element:
arr_2d[1,2]

# 28. Using boolean indexing, extract elements greater than 5 from the given NumPy array.

# given array
arr = np.array([3, 8, 2, 10, 5, 7])


# extract elements greater than 5:
# condition
flag = arr > 5

# elements:
arr1 = arr[flag]
print('this is the extracted elementd' ,arr1)

# 29. Perform basic slicing to extract elements from index 2 to 5 (inclusive) from the given NumPy array.

# given array
arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])

# slicing:
arr[2:5]

#  30. Slice the 2D NumPy array to extract the sub-array `[[2, 3], [5, 6]]` from the given array.

# given array:
arr_2d = np.array([[1,2,3],
                  [4,5,6],
                  [7,8,9]])

# extract  sub-array:
sub_arr = arr_2d[0:2 ,1:3]
sub_arr

# 31.Write a NumPy function to extract elements in specific order from a given 2D array based on indices
#    provided in another array.

# create the array and the index array:
arr = np.array([[1, 2, 3],
                [4, 5, 6],
                [7, 8, 9]])

indices =np.array([[0,2],
                  [0,0],
                  [2,0],
                  [1,2]])


# define the function:
def extracted_array(array , index_array):
    return array[ index_array[ : , 0] , index_array[ : , 1]]

# call the function:
extracted_array(arr , indices)

# 32. Create a NumPy function that filters elements greater than a threshold from a given 1D array using
#     boolean indexing.

# create the array and threshold_value:
arr =np.array([12,15,20,5,6,8,9,13,11,24])
threshold_value =9

# create the function:
def filter_array(array,threshold_value):
      return array[array > threshold_value]

# call the function:
filter_array(arr,threshold_value)

# 33. Develop a NumPy function that extracts specific elements from a 3D array using indices provided in three
#     separate arrays for each dimension.

# create a 3D array:
arr = np.random.randint(1,10 , (2,3,3))
print('this is 3D array: \n' , arr)

# create 3 index:
index1 = np.array([0,1])
index2 = np.array([1,2])
index3 = np.array([0,2])

# define the function:
def  extracted_array(array , index1 ,index2 , index3):
    return array[index1 ,index2 , index3]


# call the function:
extracted_array(arr , index1 ,index2 , index3)

# 34. Write a NumPy function that returns elements from an array where both two conditions are satisfied
#     using boolean indexing.

# create a array:
arr = np.random.randint(1,18 , (2,4,3))
print('this is 3D array: \n' , arr)

condtn1 = (arr <14)
condtn2 = (arr >9)

# define function:
def filter_arr(array, condition1,condition2):
    return array[condition1 & condition2]

# call the function:
filter_arr(arr, condtn1,condtn2)

# 35. Create a NumPy function that extracts elements from a 2D array using row and column indices provided
#     in separate arrays.

# create the array :
arr = np.array([[1, 2, 3],
                [4, 5, 6],
                [7, 8, 9]])

# Row and column indices
row_indices = np.array([0, 1, 2])
col_indices = np.array([2, 1, 0])


# define the function:
def filter_array(array ,row_indices , col_indices):
    return array[row_indices , col_indices]


# call the function:
filter_array(arr ,row_indices , col_indices)

# 36. Given an array arr of shape (3, 3), add a scalar value of 5 to each element using NumPy broadcasting.

# create an array
arr = np.random.randint(1,20 , (3,3))
print('this is a 3x3 array', arr)

# broadcasting:
arr1 = arr+5
arr1

# 37. Consider two arrays arr1 of shape (1, 3) and arr2 of shape (3, 4). Multiply each row of arr2 by the
#     corresponding element in arr1 using NumPy broadcasting.

# create two arrays:
arr1 = np.random.randint(1,15 , (1,3))
arr2 = np.random.randint(1,20 , (3,4))
print('this is arr1', arr1)
print('this is arr2', arr2)

# broadcasting:
arr3 = arr1.T * arr2      # transpose the arr1 to multiply each element of arr2 with the corresponding element of arr1
arr3

# 38. Given a 1D array arr1 of shape (1, 4) and a 2D array arr2 of shape (4, 3), add arr1 to each row of arr2 using
#     NumPy broadcasting.

# create two arrays:
arr1 = np.random.randint(1,15 , (1,4))
arr2 = np.random.randint(1,20 , (4,3))
print('this is arr1', arr1)
print('this is arr2', arr2)

# broadcasting:
arr3 = arr1.T + arr2      # transpose the arr1 to add each element of arr2 with the corresponding element of arr1
arr3

# 39. Consider two arrays arr1 of shape (3, 1) and arr2 of shape (1, 3). Add these arrays using NumPy
#     broadcasting.

# create two arrays:
arr1 = np.random.randint(1,15 , (3,1))
arr2 = np.random.randint(1,20 , (1,3))
print('this is arr1', arr1)
print('this is arr2', arr2)

# broadcasting:
arr3 = arr1 + arr2
arr3

# 40. Given arrays arr1 of shape (2, 3) and arr2 of shape (2, 2), perform multiplication using NumPy
#   broadcasting. Handle the shape incompatibility.

# create two arrays:
arr1 = np.random.randint(1,15 , (2,3))
arr2 = np.random.randint(1,20 , (2 ,2))
print('this is arr1', arr1)
print('this is arr2', arr2)

# broadcasting:
arr3 = np.expand_dims(arr1 , axis =2) * np.expand_dims(arr2 , axis = 1)
print('broadcastring result' , arr3)

# 41. Calculate column wise mean for the given array:
# given array
arr = np.array([[1, 2, 3], [4, 5, 6]])

# column wise mean:
np.mean(arr , axis =0)

# 42. Find maximum value in each row of the given array:
# given array
arr = np.array([[1, 2, 3], [4, 5, 6]])

# row wise max values:
np.max(arr , axis =1)

# 43. For the given array, find indices of maximum value in each column.

# given array
arr = np.array([[1, 2, 3], [4, 5, 6]])
print('given array \n',arr)


# find the indices:
print('indices of the max values \n' , np.argmax(arr , axis = 0))

# 44. For the given array, apply custom function to calculate moving sum along rows.

arr = np.array([[1, 2, 3], [4, 5, 6]])

# perform the cumsum along the rows
np.cumsum(arr , axis =1)

# 45. In the given array, check if all elements in each column are even.

# arr = np.array([[2, 4, 6], [3, 5, 7]])

# # check the element are even or not:
bool_values=(arr % 2 == 0).all(axis=1)                # condition: check  column wise


if all(bool_values) :
    print('all elements are even numbers')
else:
    print('all elements are even not numbers')

# 46. Given a NumPy array arr, reshape it into a matrix of dimensions `m` rows and `n` columns. Return the
#     reshaped matrix.

original_array = np.array([1, 2, 3, 4, 5, 6])

# this is the reshaped matrix:
reshaped_matrix = original_array.reshape(3,2)
reshaped_matrix

# 47. Create a function that takes a matrix as input and returns the flattened array.

input_matrix = np.array([[1, 2, 3], [4, 5, 6]])

# define the function
def flat_matrix(arr):
    return arr.flatten()

# flatten the matrix:
flat_matrix(input_matrix)

# 48. Write a function that concatenates two given arrays along a specified axis.

array1 = np.array([[1,2] , [3,4]])
array2 = np.array([[5,6] , [7,8]])

# concatination: axis= 0
np.concatenate((array1 , array2) , axis =0)

# 49. Create a function that splits an array into multiple sub-arrays along a specified axis.

original_array = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

# define the function:
def split_array(arr, axis, indices_or_sections):
    return np.split(arr, indices_or_sections, axis=axis)

# call the function:
split_array(original_array, 0 , 3)

# 50. Write a function that inserts and then deletes elements from a given array at specified indices.

original_array = np.array([1,2,3,4,5])
indices_to_insert = [2,4]
values_to_insert = [10,11]
indices_to_delete = [1,3]


# define the function:
def insert_and_delete_elements(arr, indices_to_insert, values_to_insert, indices_to_delete):
    arr = np.insert(arr, indices_to_insert, values_to_insert)
    sorted_indices_to_delete = sorted(indices_to_delete, reverse=True)

    for index in sorted_indices_to_delete:
        arr = np.delete(arr, index)
    return arr

# call the function:
insert_and_delete_elements(original_array, indices_to_insert, values_to_insert, indices_to_delete)

# 51. Create a NumPy array `arr1` with random integers and another array `arr2` with integers from 1 to 10.
#     Perform element-wise addition between `arr1` and `arr2`.

arr1 = np.random.randint(1,10 ,(3,2))
arr2 = np.random.randint(1,10 ,(3,2))

print('this is arr1 \n' , arr1)
print('this is arr2 \n' , arr2)
# element wise addition:
np.add(arr1,arr2)

# 52. Generate a NumPy array `arr1` with sequential integers from 10 to 1 and another array `arr2` with integers
# from 1 to 10. Subtract `arr2` from `arr1` element-wise.

arr1 = np.array([10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ])
arr2 = np.array([1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ])

# element wise subtraction:
np.subtract(arr1,arr2)

# 53. Create a NumPy array `arr1` with random integers and another array `arr2` with integers from 1 to 5.
#     Perform element-wise multiplication between `arr1` and `arr2`.

arr1 = np.random.randint(1,10,5)
arr2 = np.array([1,2,3,4,5])

# element wise multipliction:
np.multiply(arr1 ,arr2)

# 54. Generate a NumPy array `arr1` with even integers from 2 to 10 and another array `arr2` with integers from 1
#     to 5. Perform element-wise division of `arr1` by `arr2`.
arr1 = np.array([2,4,6,8,10])
arr2 = np.array([1,2,3,4,5])

# element wise division:
np.divide(arr1 , arr2)

# 55. Create a NumPy array `arr1` with integers from 1 to 5 and another array `arr2` with the same numbers
#     reversed. Calculate the exponentiation of `arr1` raised to the power of `arr2` element-wise.

arr1 = np.array([1,2,3,4,5])
arr2 = np.array([5,4,3,2,1])

# the exponentiation of `arr1` raised to the power of `arr2` element-wise:
arr1**arr2

# 56. Write a function that counts the occurrences of a specific substring within a NumPy array of strings.

arr = np.array(['hello', 'world', 'hello', 'numpy', 'hello'])

# calculate the occurance of substring 'hello'
np.char.count(arr , 'hello').sum()

# 57. Write a function that extracts uppercase characters from a NumPy array of strings.

arr = np.array(['Hello', 'World', 'OpenAI', 'GPT'])

# define the function:
def extract_upper(array):
    return array[np.char.isupper(array)]

# call the function:
print('this/these is/are the upper character in the array',extract_upper(arr))

# 58. Write a function that replaces occurrences of a substring in a NumPy array of strings with a new string.

# given string:
arr = np.array(['apple', 'banana', 'grape', 'pineapple'])

# define the string:
def replace_substring(array, old_substring, new_substring):
    def replace_in_string(string):
        return string.replace(old_substring, new_substring)

    return np.array([replace_in_string(string) for string in array])

# call the function:
replaced_arr = replace_substring(arr, 'apple', 'orange')
print("replaced array:", replaced_arr)

# 59. Write a function that concatenates strings in a NumPy array element-wise.

arr1 = np.array(['Hello' , 'World'])
arr2 = np.array(['Open' , 'AI'])

# string concatenation
np.char.add(arr1 , arr2)

# 60. Write a function that finds the length of the longest string in a NumPy array.

arr = np.array(['apple', 'banana', 'grape', 'pineapple'])

# define the function:
def longest_string_length(arr):
    lengths = [len(i) for i in arr]
    return max(lengths)

# call the function:
longest_string_length(arr)

# 61. Create a dataset of 100 random integers between 1 and 1000. Compute the mean, median, variance, and
#     standard deviation of the dataset using NumPy's functions.

# create the dataset
arr = np.random.randint(1,1000 , (5,20))
print('the dataset is',arr)


# Compute the mean, median, variance, and  standard deviation:
print('this is the mean of the dataset ' ,np.mean(arr))
print('this is the median of the dataset ' ,np.median(arr))
print('this is the variance of the dataset ' ,np.var(arr))
print('this is the standard deviation of the dataset ' ,np.std(arr))

# 62. Generate an array of 50 random numbers between 1 and 100. Find the 25th and 75th percentiles of the dataset.

# create the dataset
arr = np.random.randint(1,100 , (5,10))
print('the dataset is',arr)

# the 25th and 75th percentiles of the dataset.
print('25th percentile of the dataset is',np.percentile(arr , 25))
print('75th percentile of the dataset is',np.percentile(arr , 75))

# 63. Create two arrays representing two sets of variables. Compute the correlation coefficient between these
# arrays using NumPy's `corrcoef` function.

age = np.arange(20 ,75)
weight = np.arange(45 , 100)

# correlation :
np.corrcoef(age,weight)     # from the output it seems linear relationship

# 64. Create two matrices and perform matrix multiplication using NumPy's `dot` function.

# create two  arrays:
arr1 = np.random.randint(1,10 ,(3,3))
arr2 = np.random.randint(1,10 ,(3,3))

print('this is arr1',arr1)
print('this is arr2',arr2)
# dot function:
print('the dot product of arr1 and arr2' , arr1.dot(arr2))

# 65. Create an array of 50 integers between 10 and 1000. Calculate the 10th, 50th (median), and 90th
#     percentiles along with the first and third quartiles.

# create the array:
arr1 = np.random.randint(10,1000 ,50)
print('this is the array \n',arr1)


#  Calculate the 10th, 50th (median), and 90th,
#  percentiles along with the  first and third quartiles.
print('this is 10th percentile' , np.percentile(arr1 , 10))
print('this is 25th (first quartile) percentile' , np.percentile(arr1 , 25))
print('this is 50th percentile' , np.percentile(arr1 , 50))
print('this is 75th (third quartile) percentile' , np.percentile(arr1 , 75))
print('this is 90th percentile' , np.percentile(arr1 , 90))

# 66. Create a NumPy array of integers and find the index of a specific element.

# create the array:
arr1 = np.array([1,6,5,8,9,12,46,78,1,1,1,1])
print('this is the array \n',arr1)

# find the index:
print('indices of the the element 1 is:  \n' ,np.argwhere(arr1 == 1))

# 67. Generate a random NumPy array and sort it in ascending order.
# create the array:
arr1 = np.array([1,6,5,8,9,12,46,78,1,1,1,1])

# sort the array:
np.sort(arr1)

# 68. Filter elements >20  in the given NumPy array.

# given array:
arr = np.array([12, 25, 6, 42, 8, 30])

# condition:(bool values)
arr > 20

# filter the element:
arr[arr > 20]

# 69. Filter elements which are divisible by 3 from a given NumPy array.

# given array:
arr = np.array([1, 5, 8, 12, 15])

# condition:
arr % 3 == 0

# filter the elements:
arr[arr % 3 == 0]

# 70. Filter elements which are ≥ 20 and ≤ 40 from a given NumPy array.

# given array:
arr = np.array([10, 20, 30, 40, 50])

# condition:
(arr >= 20) & (arr<=40)

# filter the elements:
arr[(arr >= 20) & (arr<=40)]

# 71. For the given NumPy array, check its byte order using the `dtype` attribute byteorder.

# given array:
arr = np.array([1, 2, 3])

# byteorder:
arr.dtype.byteorder

# 73. For the given NumPy array, swap its byte order without modifying the original array using
#    `newbyteorder()`.

# given array:
arr = np.array([1, 2, 3], dtype=np.int32)

# swap byte order:
swap_arr = arr.newbyteorder()


# all outputs:
print('original array:', arr)
print('swap array:' , swap_arr)

print('original byteorder :' ,arr.dtype.byteorder )
print('original byteorder :' ,swap_arr.dtype.byteorder )

# 74. For the given NumPy array and swap its byte order conditionally based on system endianness using
#    `newbyteorder()`.

# given array:
arr = np.array([1, 2, 3], dtype=np.int32)

#  check byte order:
import sys
system_endiness = sys.byteorder

# condition based swaping:
if system_endiness == 'little':
    swap_arr = arr.newbyteorder('>')
else:
    swap_arr = arr.newbyteorder('<')

# all outputs:
print('original array:', arr)
print('swap array:' , swap_arr)

print('original byteorder :' ,arr.dtype.byteorder )
print('original byteorder :' ,swap_arr.dtype.byteorder )

# 75. For the given NumPy array, check if byte swapping is necessary for the current system using `dtype`
#   attribute `byteorder`.


# Check the system byte order:
import sys
system_endianness = sys.byteorder

# Check the array's byte order:
array_byteorder = arr.dtype.byteorder

# Determine if byte swapping is necessary:
if array_byteorder == "=":
    # The array is in the system's native byte order, no swap necessary
    swap_needed = False
elif (system_endianness == 'little' and array_byteorder == '>') or \
     (system_endianness == 'big' and array_byteorder == '<'):
    # If system is little-endian but array is big-endian, or vice versa
    swap_needed = True
else:
    swap_needed = False


# all outputs:
print('system_endiness is:',system_endiness)
print('array_byteorder is:' ,array_byteorder)
print('swap needed?', swap_needed)

# 76. Create a NumPy array `arr1` with values from 1 to 10. Create a copy of `arr1` named `copy_arr` and modify
#     an element in `copy_arr`. Check if modifying `copy_arr` affects `arr1`.

# create an array:
arr1 = np.arange(1,11)

# copy: (deep copy)
copy_arr = np.copy(arr1)

# modification:
copy_arr[5] = 500

# see the output:
print('this is original array:',arr1)
print('this is copy array after modification:', copy_arr)
Print('this is a deep copy so it will  not effect the original array')

# 77. Create a 2D NumPy array `matrix` of shape (3, 3) with random integers. Extract a slice `view_slice` from
#     the matrix. Modify an element in `view_slice` and observe if it changes the original `matrix`.

# create an matrix:
arr = np.random.randint(1,10,(3,3))
print('original array:' , arr)

# slicing:
view_slice =  arr[0:3 , 1:3]
print('view_slice array' , view_slice)

# modify the view_slice:
view_slice[1,0] = 20
print('modified viw_slice array' , view_slice)

# original array  after view_sliced array modification:
print('original array  after  all operation:',arr)

# 78. Create a NumPy array `array_a` of shape (4, 3) with sequential integers from 1 to 12. Extract a slice
#    `view_b` from `array_a` and broadcast the addition of 5 to view_b. Check if it alters the original `array_a`.

# create an matrix:
array_a = np.arange(1, 13).reshape(4, 3)
print('original array: \n' , array_a)

# extract a slice 'view_b':
view_b = array_a[0:2 , 1:3]
print('view_b : \n',view_b )

# broadcasting:
print('view_b after broadcasting\n',view_b+5)
print('original array after all  modification \n' , array_a)
print('no modification on original array')

# 79. Create a NumPy array `orig_array` of shape (2, 4) with values from 1 to 8. Create a reshaped view
#     `reshaped_view` of shape (4, 2) from orig_array. Modify an element in `reshaped_view` and check if it
#     reflects changes in the original `orig_array`.

# create the array:
orig_array = np.arange(1,9).reshape(2, 4)
print('original array: \n' , orig_array)

# reshape:
reshaped_view = orig_array.reshape(4,2)
print('reshaped array: \n', reshaped_view)

# modification:
reshaped_view[1 , 0] = 200
print('reshaped array after modification: \n', reshaped_view)
print('original array after all modification: \n' , orig_array)
print('modification happens on original array after all operation')

# 80. Create a NumPy array `data` of shape (3, 4) with random integers. Extract a copy `data_copy` of
#     elements greater than 5. Modify an element in `data_copy` and verify if it affects the original `data`.

# create an array:
arr1 = np.random.randint(1,15 , (3,4))
print('this is original array: \n',arr1)

# condition:
arr1 > 5

# copy: (deep copy)
data_copy = np.copy(arr[arr > 5])
print('this is the copy_array: \n' , data_copy)
# modification:
data_copy[3] = 499


# # see the output:
print('this is copy array after modification: \n', data_copy)
print('this is original array after modification: \n',arr1)
print('this is a deep copy so it will  not effect the original array')

# 81. Create two matrices A and B of identical shape containing integers and perform addition and subtraction
#     operations between them.

# creating arrays:
A = np.random.randint(1,11,(3,4))
B = np.random.randint(1,11,(3,4))

print('this is matrix A \n',A)
print('this is matrix b \n',B)

# addition:
print('this is addition of A and B \n', A + B)

# subtraction:
print('this is subtraction of A and B \n' , A-B)

# 82. Generate two matrices `C` (3x2) and `D` (2x4) and perform matrix multiplication.

# creating arrays:
C = np.random.randint(1,11,(3,2))
D = np.random.randint(1,11,(2,4))

print('this is matrix C \n',C)
print('this is matrix D \n',D)

# addition:
print('this is multiplication of C and D \n', C @ D)

# 83. Create a matrix `E` and find its transpose.

# creating arrays:
E = np.random.randint(1,11,(2,4))
print('this is matrix E \n',E)

# transpose:
print('transpose of matrix E \n' ,E.T)

# 84. Generate a square matrix `F` and compute its determinant.

# creating arrays:
F = np.random.randint(1,11,(4,4))
print('this is matrix F \n',F)

# determinant of matrix F:
print('determinant of matrix F:', np.linalg.det(F) )

# 85. Create a square matrix `G` and find its inverse.

# creating arrays:
G = np.random.randint(1,11,(4,4))
print('this is matrix G \n',G)

# determinant of matrix F:
print('inverse of matrix G:', np.linalg.inv(G) )







